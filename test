import os
import time
import random

try:
    # 這是控制鍵盤輸入的函式庫，需要額外安裝
    # 您可以在終端機中執行: pip install keyboard
    import keyboard
except ImportError:
    print("錯誤：找不到 'keyboard' 函式庫。")
    print("請使用 'pip install keyboard' 命令來安裝它。")
    print("注意：在某些作業系統 (如 Linux) 上，此命令可能需要 root 權限 (sudo)。")
    exit()

# --- Model (模型) ---
# 負責所有遊戲的核心邏輯、數據和規則

class TetrisModel:
    """
    管理俄羅斯方塊遊戲的數據和邏輯
    """
    def __init__(self, width=12, height=22):
        self.width = width
        self.height = height
        # 定義各種方塊的形狀和顏色
        self.shapes = [
            ([[1, 1, 1, 1]], 1),                      # I (青色)
            ([[1, 1, 0], [0, 1, 1]], 2),              # Z (紅色)
            ([[0, 1, 1], [1, 1, 0]], 3),              # S (綠色)
            ([[1, 1, 1], [0, 1, 0]], 4),              # T (紫色)
            ([[1, 1, 1], [1, 0, 0]], 5),              # L (橘色)
            ([[1, 1, 1], [0, 0, 1]], 6),              # J (藍色)
            ([[1, 1], [1, 1]], 7)                     # O (黃色)
        ]
        self.colors = [
            '\033[97m',  # 0: 背景 (白色)
            '\033[96m',  # 1: I (青色)
            '\033[91m',  # 2: Z (紅色)
            '\033[92m',  # 3: S (綠色)
            '\033[95m',  # 4: T (紫色)
            '\033[93m',  # 5: L (橘色)
            '\033[94m',  # 6: J (藍色)
            '\033[33m',  # 7: O (黃色)
            '\033[90m'   # 8: 邊界 (灰色)
        ]
        self.reset()

    def reset(self):
        """
        重置遊戲狀態到初始值
        """
        self.board = [[0] * self.width for _ in range(self.height)]
        self.score = 0
        self.level = 1
        self.lines_cleared = 0
        self.game_over = False
        self.paused = False
        self.new_piece()
        self.new_piece() # 產生當前和下一個方塊

    def new_piece(self):
        """
        產生一個新的方塊
        """
        self.current_piece = getattr(self, 'next_piece', self.get_random_piece())
        self.next_piece = self.get_random_piece()
        self.current_piece_x = self.width // 2 - len(self.current_piece['shape'][0]) // 2
        self.current_piece_y = 0
        # 如果新方塊一產生就碰撞，表示遊戲結束
        if self.check_collision(self.current_piece['shape'], (self.current_piece_x, self.current_piece_y)):
            self.game_over = True

    def get_random_piece(self):
        """
        從形狀列表中隨機選擇一個方塊
        """
        shape, color_index = random.choice(self.shapes)
        return {'shape': shape, 'color': color_index}

    def check_collision(self, shape, pos):
        """
        檢查指定位置的方塊是否會發生碰撞
        """
        px, py = pos
        for y, row in enumerate(shape):
            for x, cell in enumerate(row):
                if cell:
                    board_y = y + py
                    board_x = x + px
                    if (board_y >= self.height or
                        board_x < 0 or
                        board_x >= self.width or
                        self.board[board_y][board_x] != 0):
                        return True
        return False

    def move(self, dx):
        """
        左右移動當前的方塊
        """
        if not self.game_over and not self.paused:
            new_x = self.current_piece_x + dx
            if not self.check_collision(self.current_piece['shape'], (new_x, self.current_piece_y)):
                self.current_piece_x = new_x

    def drop(self):
        """
        向下移動方塊，直到發生碰撞
        """
        if not self.game_over and not self.paused:
            while not self.check_collision(self.current_piece['shape'], (self.current_piece_x, self.current_piece_y + 1)):
                self.current_piece_y += 1
            self.lock_piece()

    def soft_drop(self):
        """
        加速下降（軟降）
        """
        if not self.game_over and not self.paused:
            if not self.check_collision(self.current_piece['shape'], (self.current_piece_x, self.current_piece_y + 1)):
                 self.current_piece_y += 1
                 # 軟降給予少量分數
                 self.score += 1
            else:
                self.lock_piece()

    def rotate(self):
        """
        旋轉方塊
        """
        if not self.game_over and not self.paused:
            shape = self.current_piece['shape']
            rotated_shape = [list(row) for row in zip(*shape[::-1])]
            # 嘗試 "牆踢" 來避免旋轉時卡住
            kick_offsets = [ (0, 0), (1, 0), (-1, 0), (2, 0), (-2, 0), (0, -1) ]
            for ox, oy in kick_offsets:
                new_x = self.current_piece_x + ox
                new_y = self.current_piece_y + oy
                if not self.check_collision(rotated_shape, (new_x, new_y)):
                    self.current_piece['shape'] = rotated_shape
                    self.current_piece_x = new_x
                    self.current_piece_y = new_y
                    return

    def lock_piece(self):
        """
        將當前方塊固定在遊戲版上
        """
        shape = self.current_piece['shape']
        for y, row in enumerate(shape):
            for x, cell in enumerate(row):
                if cell:
                    self.board[y + self.current_piece_y][x + self.current_piece_x] = self.current_piece['color']
        self.clear_lines()
        self.new_piece()

    def clear_lines(self):
        """
        檢查並清除已滿的行
        """
        lines_to_clear = [i for i, row in enumerate(self.board) if all(cell != 0 for cell in row)]
        
        if lines_to_clear:
            num_cleared = len(lines_to_clear)
            self.lines_cleared += num_cleared
            # 根據一次清除的行數給予不同分數
            score_map = {1: 100, 2: 300, 3: 500, 4: 800}
            self.score += score_map.get(num_cleared, 0) * self.level
            
            # 從上到下刪除已滿的行
            for index in sorted(lines_to_clear, reverse=True):
                del self.board[index]
                self.board.insert(0, [0] * self.width)
            
            # 更新等級
            self.level = 1 + self.lines_cleared // 10

    def update(self):
        """
        遊戲狀態的主要更新函數，由計時器驅動
        """
        if not self.game_over and not self.paused:
            if not self.check_collision(self.current_piece['shape'], (self.current_piece_x, self.current_piece_y + 1)):
                self.current_piece_y += 1
            else:
                self.lock_piece()

    def toggle_pause(self):
        """
        切換暫停狀態
        """
        if not self.game_over:
            self.paused = not self.paused

# --- View (視圖) ---
# 負責將模型的數據渲染到螢幕上

class TetrisView:
    """
    負責在主控台渲染遊戲畫面
    """
    def __init__(self, model):
        self.model = model
        self.block_char = "■ "  # 使用兩個字元讓方塊更接近正方形

    def clear_screen(self):
        """
        清除主控台畫面
        """
        os.system('cls' if os.name == 'nt' else 'clear')

    def render(self):
        """
        渲染整個遊戲畫面
        """
        self.clear_screen()
        
        # 創建一個臨時的顯示板來繪製當前移動的方塊
        display_board = [row[:] for row in self.model.board]
        
        piece_shape = self.model.current_piece['shape']
        piece_color = self.model.current_piece['color']
        px, py = self.model.current_piece_x, self.model.current_piece_y
        
        for y, row in enumerate(piece_shape):
            for x, cell in enumerate(row):
                if cell:
                    if 0 <= py + y < self.model.height and 0 <= px + x < self.model.width:
                        display_board[py + y][px + x] = piece_color

        # 頂部邊界
        print(self.model.colors[8] + "╔" + "═" * (self.model.width * 2) + "╗" + " Next Block" + self.model.colors[0])

        for y, row in enumerate(display_board):
            # 左邊界
            print(self.model.colors[8] + "║" + self.model.colors[0], end="")
            for cell in row:
                if cell == 0:
                    print("  ", end="") # 空白格
                else:
                    print(self.model.colors[cell] + self.block_char + self.model.colors[0], end="")
            # 右邊界
            print(self.model.colors[8] + "║" + self.model.colors[0], end="")
            
            # 繪製右側資訊欄
            if y == 1:
                self.print_next_piece(y)
            elif y == 6:
                 print(f" Level: {self.model.level}", end="")
            elif y == 7:
                 print(f" Score: {self.model.score}", end="")
            elif y == 8:
                 print(f" Lines: {self.model.lines_cleared}", end="")
            elif y == 11:
                 print(" Controls:", end="")
            elif y == 12:
                 print("   A: Left", end="")
            elif y == 13:
                 print("   D: Right", end="")
            elif y == 14:
                 print("   S: Soft Drop", end="")
            elif y == 15:
                 print("   W: Rotate", end="")
            elif y == 16:
                 print(" Space: Hard Drop", end="")
            elif y == 17:
                 print("   P: Pause", end="")
            elif y == 18:
                 print("   Q: Quit", end="")
            
            print() # 換行

        # 底部邊界
        print(self.model.colors[8] + "╚" + "═" * (self.model.width * 2) + "╝" + self.model.colors[0])
        
        if self.model.paused:
            print("\n--- PAUSED ---")
        if self.model.game_over:
            print("\n--- GAME OVER ---")
            print(f"Final Score: {self.model.score}")

    def print_next_piece(self, start_y):
        """
        在右側資訊欄繪製下一個方塊的預覽
        """
        next_shape = self.model.next_piece['shape']
        next_color = self.model.next_piece['color']
        
        for y, row in enumerate(next_shape):
            # 為了對齊，在每行前面加一個空格
            print(" ", end="")
            for x, cell in enumerate(row):
                if cell:
                    print(self.model.colors[next_color] + self.block_char + self.model.colors[0], end="")
                else:
                    print("  ", end="")
            
            # 如果不是最後一行，就換行並移動到正確的垂直位置
            if y < len(next_shape) - 1:
                print()
                # 重新打印邊界，保持畫面完整
                print(self.model.colors[8] + "║" + " " * (self.model.width * 2 + 1) + "║" + self.model.colors[0], end="")
                
# --- Controller (控制器) ---
# 負責處理用戶輸入、管理遊戲循環和協調模型與視圖

class TetrisController:
    """
    處理用戶輸入並管理遊戲主循環
    """
    def __init__(self, model, view):
        self.model = model
        self.view = view
        self.last_update_time = time.time()
        self.setup_input_hooks()
        self.running = True

    def get_fall_speed(self):
        """
        根據等級計算方塊下落速度
        """
        return max(0.1, 0.8 - (self.model.level - 1) * 0.05)

    def setup_input_hooks(self):
        """
        設定鍵盤事件的響應函數
        """
        keyboard.on_press_key('a', lambda _: self.model.move(-1))
        keyboard.on_press_key('left', lambda _: self.model.move(-1))
        
        keyboard.on_press_key('d', lambda _: self.model.move(1))
        keyboard.on_press_key('right', lambda _: self.model.move(1))
        
        keyboard.on_press_key('s', lambda _: self.model.soft_drop())
        keyboard.on_press_key('down', lambda _: self.model.soft_drop())
        
        keyboard.on_press_key('w', lambda _: self.model.rotate())
        keyboard.on_press_key('up', lambda _: self.model.rotate())
        
        keyboard.on_press_key('space', lambda _: self.model.drop())
        
        keyboard.on_press_key('p', lambda _: self.model.toggle_pause())
        
        keyboard.on_press_key('q', lambda _: self.quit_game())

    def quit_game(self):
        """
        設置旗標以退出遊戲
        """
        self.running = False

    def run(self):
        """
        遊戲主循環
        """
        while self.running and not self.model.game_over:
            current_time = time.time()
            delta_time = current_time - self.last_update_time
            
            if delta_time > self.get_fall_speed():
                self.model.update()
                self.last_update_time = current_time

            self.view.render()
            
            # 短暫休眠以降低 CPU 使用率，同時保持響應性
            time.sleep(0.02)
        
        # 遊戲結束後顯示最後畫面
        self.view.render()


# --- Main Execution (主程式入口) ---
if __name__ == "__main__":
    print("正在啟動俄羅斯方塊...")
    print("請確保您的終端機視窗足夠大以獲得最佳體驗。")
    time.sleep(2)
    
    # 建立 MVC 元件
    game_model = TetrisModel()
    game_view = TetrisView(game_model)
    game_controller = TetrisController(game_model, game_view)
    
    # 執行遊戲
    game_controller.run()
    
    print("\n感謝遊玩！")
    # 移除所有鍵盤掛鉤，以確保程式乾淨退出
    keyboard.unhook_all()

